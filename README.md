# vog - value object generator

vog is a zero-dependcy Object-Oriented PHP Preprocessor that generates immutable data types based on vog definitions. 
The syntax is not inspired by Haskell and thus readable. 

## Table of contents

1. [Credits](#Credits) 

2. [Installation](#Installation)

3. [Usage](#Usage)

4. [valueFile](#valueFile)

5. [enum](#enum)

6. [nullableEnum](#nullableEnum)

7. [valueObject](#valueObject)

## Credits

This is basically a ripoff of https://github.com/prolic/fpp, but rewritten from scratch, with less fancy 
but readable code, full test coverage and proper documentation. 

## Installation

vog can be most easily installed with composer:
`composer require marvinwank/vog`

## Usage and subcommands

After installing with composer, there is a plain php file in `vendor/marvinwank/vog`, which can be called from the CLI. It has multiple subcommands.  

#### generate

The `generate` subcommand is the core of vog. It allows you to generate immutable PHP objects from a JSON definition as prescribed below. It takes one additional argument: the path to the json file with the definitions.

Example call: `./vendor/marvinwank/vog/vog.php generate ./app/value/value.json`

#### fpp_convert

This subcommand allows you to convert existing `.fpp` files into vog value files.  

**WARNING**: This does ONLY work on enums and regular php classes generated by fpp All other fpp artifacts can NOT yet be converted!  

`fpp_convert` has two arguments:   

The first one is required, it is the path to the .fpp file you want to convert.  

The second one is optional, it is the output path of the .json file, to which the .fpp file is converted. If this argument is not set, the generated file will have the same name as the original one, but with .json instead of .fpp.

## valueFile

The raw data of the objects to be generated by vog a stored in the value file in json format. 
On the root level of the value file, you have to provide the full path to your projects root with the key `root_path`.
No `/` is necessary at the end

Example:

```json
{
  "root_path": "/home/example_user/example_project/src",


  "models/values": [
      {
        "type": "enum",
        "name": "DietStyle",
        "values": {
          "EVERYTHING": "everything",
          "VEGETARIAN": "vegetarian",
          "VEGAN": "vegan"
        }
      }
  ]
}
```

As you can already see in the example, the value file also has an array at the top level, with the key of it being a path. 
In this array, an Enum with the name of "DietStyle" is given. When generated, its full path will be 
`root_path` + `<key of the path array>` + `name` + `.php`, so in this example

`/home/example_user/example_project/src/models/values/DietStyle.php`

Its namespace will be automatically generated from the path specification according to PSR-4, so in this case it would be 
`Models\Values` 

Any number of objects may be defined in each path array and any number of path arrays may be given in the value file

*Note:* There can be multiple value files although this is not recommended, because you can define paths in the value
file and multiple value files require multiple calls.

#### generic properties

These properties of the json-Object are either avaiable or required for alle data types

| name       | data type | default | optionality      | description                                                                                               |
| ---------- | --------- | ------- | ---------------- | --------------------------------------------------------------------------------------------------------- |
| type       | string    | -       | required for all | defines the type of value object to be generated                                                          |
| name       | string    | -       | required for all | defines both the php class name and file name of the value object to be generated                         |
| values     | object    | -       | required for all | defines the values to be represented by the value object to be generated. Syntax and effect vary by type. |
| extends    | ?string   | ""      | optional         | Optionally states the name of the class this object should extend                                         |
| implements | array     | []      | optional         | Optionally states the name(s) of the interface(s) this object should implement                            |

## enum

An Enum is a class which can hold any value out of a specific array of given options. For example, the value of  
an Enum called `DietStyle` could be any of "omnivore", "vegetarian" or "vegan". In vog, such an Enum would be defined
as follows:

```json
{
  "root_path": "/home/example_user/example_project/src",
  "models/values": [
    {
      "type": "enum",
      "name": "DietStyle",
      "values": {
        "OMNIVORE": "Omnivore",
        "VEGETARIAN": "Vegetarian",
        "VEGAN": "Vegan"
      }
    }
  ]
}
```

Let's have a look at the "values" object of our enum. This object defines the possible values our Enum will be able to hold.
The keys refer to the **name** of the value, while the values refer to the, well, **value**. First of, PHP constants will be
generated from the value object. This will look as follows: 

```php
    public const OPTIONS = [ "OMNIVORE" => "Omnivore", "VEGETARIAN" => "Vegetarian", "VEGAN" => "Vegan",];

    public const OMNIVORE = 'Omnivore';
    public const VEGETARIAN = 'Vegetarian';
    public const VEGAN = 'Vegan';
```

### Instantiating a generated Enum

An Enum cannot be directly constructed, instead there are 3 different ways to createn an enum

#### 1. calling the static methods

Each Enum will have public static methods named according to its **keys** defined in the value file. In this case:

```php
       public static function OMNIVORE(): self
       public static function VEGETARIAN(): self
       public static function VEGAN(): self
```

Calling the `OMNIVORE` method will return an Enum with the value assigned to the key `OMNIVORE` in the value file

#### 2. from value

You can also call the static `fromValue` method, which accepts any value defined in the value file. So in this case either
"Omnivore", "Vegetarian" or "Vegan".

#### 3. from name

Similarily to "fromValue", there also is static method `fromName`, where you can construct an enum form any value defined 
in the value file 

### other Methods

```php
    /** Compares two enums of the same type for equality */
    public function equals(?self $other): bool
    /**  Returns the name of the value of the enum */
    public function name(): string
    /** Returns the value of the enum */
    public function value(): string
    /** Returns the name of the value of the enum */
    public function toString(): string
    /** Same es toString(), but provides support for strval() */
    public function __toString(): string
```

## nullableEnum

The same as the regular Enum except it also accepts `null` in the `fromName` and `fromValue` methods and returns `null`
on `name()`, `value()` and `toString()`. It has the same structure in the value file as the enum and its name is `nullableEnum`

## valueObject

A value object is an object that once constructed cannot be changed. It has getters, but no setters. Also, it doesn't do any business logic at all. It truly is an object that holds values - and nothing more.

#### vog definition

```json
    {
      "type": "valueObject",
      "name": "Recipe",
      "values": {
        "title": "string",
        "minutes_to_prepare": "?int",
        "rating": "float",
        "diet_style": "DietStyle"
      },
      "string_value": "title"
    }
```

The properties are similar to those of the Enum. The `values` object follows the `"identifier": "datatype"` syntax. 

If you don't want to specify a datatype, simply provide an empty string. 

Notice that you may also define nullable types and object types. You'll have to provide the namespace to the object, but in this case, "DietStyle" hast the same namespace as "Recipe".

#### result

Vog will generate private class members according to the definition in the value file.

```php
final class Recipe
{
    private string $title;
    private ?int $minutes_to_prepare;
    private float $rating;
    private DietStyle $diet_style;
```

The class must be regularily instantiated by a constructor and the members are avaiable by getter functions with the same name as the members: 

```php
    public function title(): string {
        return $this->title;
    }
```

As it is an immutable value object, there are no setters. Instead, you'll have to create entirely new objects if you want to alter a value. This is made easy by the `with_` methods: 

```php
    public function with_title (string $title):self
    {
        return new self($title,$this->minutes_to_prepare,$this->rating,$this->diet_style,);
    }
```

`with_` methods will be generated for each member defined in the value file. 

#### fromArray

A value object can also be created from the static `fromArray` method.  The keys of the array must match the property names.

#### toArray

A value object may also be converted into an associative array, for example for data transfer purposes. Note that this is a **deep conversion**, so any non-primitive member will be serialized. 

This as ensured by first checking the non-primitive member for a `toArray` function. If it does have one, this function is called. 

If it does not have one, `strval()` is called on the object.

Since all elements generated by vog either have a `toArray` method or a fitting implementation of `__toString()`, no strange effects occur when building vog value objects solely on vog generated elements. However, use that function with caution when mixing other objects into vog value objects